# Prompt 09 - Versão Web Desktop e Atualização do Modelo de I.A.

## Contexto

Este projeto é uma aplicação de agendamento de barbearias chamada **Aparatus Barber**. Atualmente a interface do chat está otimizada apenas para mobile (390px). Precisamos:

1. Adaptar a interface para uma versão web desktop responsiva
2. Atualizar o modelo de I.A. para usar recursos mais avançados

## Tarefa Principal

### Parte 1: Versão Web Responsiva

Transformar a página de chat (@app/chat/page.tsx) em uma interface responsiva e premium que funcione perfeitamente em:
- **Desktop** (1920px, 1440px, 1280px)
- **Tablet** (1024px, 768px)
- **Mobile** (390px - layout atual)

#### Requisitos de Layout Desktop:

1. **Layout Split-Screen (Desktop):**
   - Sidebar à esquerda (320px) com:
     - Logo "Aparatus" no topo
     - Histórico de conversas anteriores (criar modelo no Prisma se necessário)
     - Botão "Nova Conversa"
     - Perfil do usuário logado no rodapé da sidebar
   - Área principal de chat centralizada (max-width: 800px)
   - Fundo com gradiente sutil ou padrão elegante

2. **Header do Chat (Desktop):**
   - Avatar do Aparatus.ai com indicador de status (online/typing)
   - Nome "Aparatus.ai" com subtítulo "Seu assistente de agendamentos"
   - Ícone de opções/configurações

3. **Área de Mensagens:**
   - Mensagens do assistente à esquerda com avatar
   - Mensagens do usuário à direita com bolha colorida
   - Suporte a rich messages:
     - Cards de barbearias com imagem, nome, endereço e rating
     - Grid de horários disponíveis clicáveis
     - Confirmação de agendamento com todos os detalhes

4. **Input de Chat Responsivo:**
   - Expandir para largura máxima de 800px no desktop
   - Manter botões de microfone e enviar
   - Adicionar botão de anexo (para futuras funcionalidades)
   - Suporte a textarea expansível para mensagens longas

5. **Animações Premium:**
   - Transição suave entre layouts (mobile ↔ desktop)
   - Efeito de "typing" enquanto a I.A. responde
   - Animação de entrada para novas mensagens
   - Hover effects elegantes em botões e cards

#### Requisitos de Responsividade:

- Mobile First: Manter o layout atual para `<=640px`
- Tablet: Sidebar colapsável, chat ocupa tela inteira
- Desktop: Layout split-screen completo

### Parte 2: Atualização do Modelo de I.A.

Atualizar @app/api/chat/route.ts para usar recursos avançados:

#### 2.1 Migrar para Gemini 2.5 Flash (se disponível) ou Gemini 2.5 Pro:

- Use Context7 para consultar a documentação mais recente do Google AI SDK
- Atualizar o modelo para `gemini-2.5-flash` ou superior

#### 2.2 Implementar Geração de UI (Generative UI):

- Usar o recurso de UI generativa do Vercel AI SDK
- Criar componentes de UI que o modelo pode renderizar:
  - `BarbershopCard`: Card com imagem, nome, endereço e serviços
  - `TimeSlotGrid`: Grid de horários disponíveis
  - `BookingConfirmation`: Resumo do agendamento confirmado
  - `BookingReceipt`: Recibo após confirmação

Use Context7 para buscar documentação do Vercel AI SDK sobre:
- Generative UI / UI Streaming
- Tool Results com componentes React
- Rich responses

#### 2.3 Melhorar o System Prompt:

- Adicionar contexto sobre a barbearia base do usuário (se houver favoritos)
- Incluir histórico de agendamentos anteriores do usuário
- Personalizar saudação com nome do usuário logado
- Adicionar capacidade de recomendar serviços baseado em histórico

#### 2.4 Novas Ferramentas (Tools):

Adicionar as seguintes ferramentas ao modelo:

```typescript
// Buscar agendamentos anteriores do usuário
getUserBookingHistory: tool({
  description: "Busca os últimos agendamentos do usuário logado",
  inputSchema: z.object({}),
  execute: async () => { /* implementar */ }
})

// Buscar detalhes de uma barbearia específica
getBarbershopDetails: tool({
  description: "Busca detalhes completos de uma barbearia específica",
  inputSchema: z.object({
    barbershopId: z.string()
  }),
  execute: async ({ barbershopId }) => { /* implementar */ }
})

// Verificar se usuário está logado
checkUserAuthentication: tool({
  description: "Verifica se o usuário está autenticado",
  inputSchema: z.object({}),
  execute: async () => { /* implementar */ }
})
```

### Parte 3: Componentes de UI para Rich Messages

Criar os seguintes componentes em @app/chat/_components/:

1. **barbershop-card.tsx:**
   - Imagem da barbearia
   - Nome e endereço
   - Rating (estrelas)
   - Lista de serviços principais
   - Botão "Ver Horários"

2. **time-slot-grid.tsx:**
   - Grid responsivo de horários (4 colunas desktop, 3 tablet, 2 mobile)
   - Horários selecionáveis com estado visual
   - Indicação de horários populares/lotando
   - Período (manhã, tarde, noite) agrupado

3. **booking-confirmation.tsx:**
   - Layout de card com todos os detalhes
   - Imagem da barbearia
   - Serviço, data, horário, preço
   - Botões "Confirmar" e "Alterar"

4. **booking-receipt.tsx:**
   - Confirmação visual de sucesso
   - Número do agendamento
   - Opção de adicionar ao calendário
   - Botão "Compartilhar"

## Requisitos Técnicos

- **SEMPRE** use componentes do shadcn/ui
- **NUNCA** use cores hard-coded, apenas variáveis do tema em @app/globals.css
- Use Framer Motion para animações premium
- Implemente loading states e skeleton loaders apropriados
- Use `useMediaQuery` ou CSS para breakpoints responsivos
- Mantenha compatibilidade com o layout mobile atual
- Use Context7 para consultar documentações necessárias

## Stack Tecnológico

- Next.js 16
- React 19
- Tailwind CSS v4
- shadcn/ui
- Framer Motion
- Vercel AI SDK
- Google Gemini 2.5 Flash (ou versão mais recente disponível)
- Prisma (para persistência de histórico de conversas, se necessário)

## Referências

- Layout atual mobile: @app/chat/page.tsx
- API atual: @app/api/chat/route.ts
- Componentes existentes: @app/chat/_components/
- Tema global: @app/globals.css
- Schema do Prisma: @prisma/schema.prisma

## Critérios de Sucesso

1. Interface funciona perfeitamente em desktop, tablet e mobile
2. Transições suaves entre breakpoints
3. Modelo de I.A. atualizado com novas capacidades
4. Rich messages renderizam corretamente
5. Performance mantida (loading < 2s)
6. Código limpo e componentizado
7. Acessibilidade mantida (WCAG 2.1)

## Priorização

1. ⭐⭐⭐ Layout Desktop responsivo
2. ⭐⭐⭐ Atualização do modelo de I.A.
3. ⭐⭐ Componentes de rich messages
4. ⭐⭐ Animações e micro-interações
5. ⭐ Histórico de conversas (sidebar)
